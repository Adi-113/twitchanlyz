<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Community Network with Adamic-Adar Predictions</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin: 0; font-family: 'Segoe UI', Tahoma, sans-serif; }
    #community { width: 100vw; height: 100vh; background: #18181b; }
    .link { stroke: #373636; stroke-width: 1px; opacity: 0.2; }
    .node { stroke: #555; stroke-width: 1px; }
    .predicted-link { stroke: #ffffff; stroke-width: 3px; stroke-dasharray: 6,4; opacity: 0.5; }
    .tooltip { position: absolute; padding: 6px 10px; background: rgba(0,0,0,0.7); color: #fff; border-radius: 4px; pointer-events: none; font-size: 12px; visibility: hidden; }
    .legend-color { width: 12px; height: 12px; }
    .legend text { fill: #fff; font-size: 12px; }
  </style>
</head>
<body>
  <div id="community"></div>
  <div id="tooltip" class="tooltip"></div>
  <script>
    const width = 3500;
    const height = 1800;
    const svg = d3.select('#community').append('svg')
      .attr('width', width)
      .attr('height', height);
    const tooltip = d3.select('#tooltip');

    d3.json('community_data.json').then(({nodes, links}) => {
      // Extract unique groups for color scale
      const groups = Array.from(new Set(nodes.map(d => d.group)));
      const color = d3.scaleOrdinal(d3.schemeDark2).domain(groups);

      // Build adjacency map for Adamic-Adar
      const nodeById = new Map(nodes.map(d => [d.id, d]));
      const neighbors = new Map();
      nodes.forEach(d => neighbors.set(d.id, new Set()));
      links.forEach(l => {
        neighbors.get(l.source).add(l.target);
        neighbors.get(l.target).add(l.source);
      });

      // Compute Adamic-Adar scores for all non-edge pairs
      const preds = [];
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const u = nodes[i].id, v = nodes[j].id;
          if (neighbors.get(u).has(v)) continue; // Skip existing edges
          const cn = [...neighbors.get(u)].filter(x => neighbors.get(v).has(x));
          if (cn.length === 0) continue; // Skip if no common neighbors
          let score = 0;
          cn.forEach(x => score += 1 / Math.log(neighbors.get(x).size));
          preds.push({u, v, score});
        }
      }
      const topPreds = preds.sort((a, b) => b.score - a.score).slice(0, 5);
      const predictedLinks = topPreds.map(d => ({source: d.u, target: d.v, score: d.score}));

      // Simulation
      const container = svg.append('g');
      svg.call(d3.zoom().scaleExtent([0.3, 5]).on('zoom', e => container.attr('transform', e.transform)));

      const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(100).strength(0.8))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 3, height / 3));

      // Draw real links
      const link = container.append('g')
        .attr('class', 'links')
        .selectAll('.link')
        .data(links)
        .join('line')
        .attr('class', 'link');

      // Draw predicted links
      const pred = container.append('g')
        .attr('class', 'predicted-links')
        .selectAll('.predicted-link')
        .data(predictedLinks)
        .join('line')
        .attr('class', 'predicted-link')
        .on('mouseover', (event, d) => {
          tooltip.html(`Predicted: ${d.source} â†” ${d.target}<br/>Score: ${d.score.toFixed(2)}`)
            .style('visibility', 'visible');
        })
        .on('mousemove', event => {
          tooltip.style('top', (event.pageY + 10) + 'px')
            .style('left', (event.pageX + 10) + 'px');
        })
        .on('mouseout', () => tooltip.style('visibility', 'hidden'));

      // Draw nodes
      const node = container.append('g')
        .attr('class', 'nodes')
        .selectAll('.node')
        .data(nodes)
        .join('circle')
        .attr('class', 'node')
        .attr('r', 8)
        .attr('fill', d => color(d.group))
        .on('mouseover', (event, d) => {
          tooltip.html(`<strong>${d.id}</strong><br/>${d.group}`)
            .style('visibility', 'visible');
        })
        .on('mousemove', event => {
          tooltip.style('top', (event.pageY + 10) + 'px')
            .style('left', (event.pageX + 10) + 'px');
        })
        .on('mouseout', () => tooltip.style('visibility', 'hidden'))
        .call(d3.drag()
          .on('start', (event, d) => {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          })
          .on('drag', (event, d) => {
            d.fx = event.x;
            d.fy = event.y;
          })
          .on('end', (event, d) => {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          })
        );

      // Legend
      const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', 'translate(90,90)')
        .style('margin-left', '25px');
      groups.forEach((g, i) => {
        const item = legend.append('g')
          .attr('class', 'legend-item')
          .attr('transform', `translate(0,${i * 20})`);
        item.append('rect')
          .attr('class', 'legend-color')
          .attr('fill', color(g))
          .attr('width', 12)
          .attr('height', 12);
        item.append('text')
          .attr('x', 16)
          .attr('y', 12)
          .text(g);
      });

      // Simulation tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        pred
          .attr('x1', d => nodeById.get(d.source).x)
          .attr('y1', d => nodeById.get(d.source).y)
          .attr('x2', d => nodeById.get(d.target).x)
          .attr('y2', d => nodeById.get(d.target).y);
        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);
      });
    });
  </script>
</body>
</html>